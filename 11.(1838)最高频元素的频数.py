'''
元素的 频数 是该元素在一个数组中出现的次数
给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1
执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数


核心是通过增加数组元素的值，使某个数成为数组中出现次数最多的数（即“最高频元素”），并计算它的最大可能频数。

示例 1:
输入：nums = [1,2,4], k = 5
输出：3
    初始数组是 [1, 2, 4]，最大允许 5 次操作。
    如果将第一个元素 1 增加 3 次，第二个元素 2 增加 2 次，数组变成 [4, 4, 4]。
    此时，4 是最高频元素，频数是 3（数组中有三个 4）。
    所以答案是 3。

示例 2:
输入：nums = [1,4,8,13], k = 5
输出：2
    初始数组是 [1, 4, 8, 13]，最大允许 5 次操作。
    可能的操作方式：
    将第一个元素 1 增加 3 次，数组变成 [4, 4, 8, 13]。此时最高频元素是 4，频数是 2。
    将第二个元素 4 增加 4 次，数组变成 [1, 8, 8, 13]。此时最高频元素是 8，频数是 2。
    将第三个元素 8 增加 5 次，数组变成 [1, 4, 13, 13]。此时最高频元素是 13，频数是 2。
    无论怎么操作，最高频元素的最大频数都是 2。

示例 3:
输入：nums = [3,9,6], k = 2
输出：1
    初始数组是 [3, 9, 6]，最大允许 2 次操作。
    因为操作次数有限，无法把两个数变成相同的值，所以每个数的频数仍然是 1。
    答案是 1。
'''


class Solution:
    def maxFrequency(self, nums, k) :
        # Step 1: 对数组进行排序
        nums.sort()

        # 初始化滑动窗口的左指针、窗口内元素的总和、最大频数
        left = 0
        total = 0  # 窗口内元素的总和
        max_freq = 0

        # Step 2: 使用滑动窗口遍历数组
        for right in range(len(nums)):
            # 扩大窗口，将 nums[right] 加入窗口，更新窗口内元素总和
            total += nums[right]

            # Step 3: 检查窗口是否有效
            # 如果操作次数超过 k，需要收缩窗口
            while (right - left + 1) * nums[right] - total > k:
                total -= nums[left]  # 移除 nums[left]，更新总和
                left += 1  # 收缩窗口

            # Step 4: 更新最大频数
            max_freq = max(max_freq, right - left + 1)

        return max_freq

